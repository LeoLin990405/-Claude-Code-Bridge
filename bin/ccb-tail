#!/bin/bash
# ccb-tail - å®æ—¶æŸ¥çœ‹ CCB è¯·æ±‚è¾“å‡ºæµ
# ç”¨æ³•: ccb-tail <request_id> [-f|--follow] [-n|--lines N]

set -e

GATEWAY_URL="${CCB_GATEWAY_URL:-http://localhost:8765}"
STREAM_DIR="$HOME/.ccb/streams"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
DIM='\033[2m'
NC='\033[0m'

show_help() {
    cat << 'EOF'
ccb-tail - å®æ—¶æŸ¥çœ‹ CCB è¯·æ±‚è¾“å‡ºæµ

ç”¨æ³•: ccb-tail [é€‰é¡¹] <request_id>
      ccb-tail --list
      ccb-tail --latest

é€‰é¡¹:
  -f, --follow       æŒç»­è·Ÿè¸ªè¾“å‡º (ç±»ä¼¼ tail -f)
  -n, --lines N      æ˜¾ç¤ºæœ€å N è¡Œ (é»˜è®¤: 20)
  --list             åˆ—å‡ºæœ€è¿‘çš„æµ
  --latest           æŸ¥çœ‹æœ€æ–°è¯·æ±‚çš„æµ
  --json             è¾“å‡º JSON æ ¼å¼
  -h, --help         æ˜¾ç¤ºå¸®åŠ©

ç¤ºä¾‹:
  ccb-tail abc123                # æŸ¥çœ‹è¯·æ±‚ abc123 çš„è¾“å‡º
  ccb-tail -f abc123             # æŒç»­è·Ÿè¸ªè¾“å‡º
  ccb-tail --latest -f           # è·Ÿè¸ªæœ€æ–°è¯·æ±‚
  ccb-tail --list                # åˆ—å‡ºæ‰€æœ‰æµ
EOF
}

# Parse arguments
FOLLOW=false
LINES=20
LIST=false
LATEST=false
JSON=false
REQUEST_ID=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -f|--follow)
            FOLLOW=true
            shift
            ;;
        -n|--lines)
            LINES="$2"
            shift 2
            ;;
        --list)
            LIST=true
            shift
            ;;
        --latest)
            LATEST=true
            shift
            ;;
        --json)
            JSON=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            REQUEST_ID="$1"
            shift
            ;;
    esac
done

# List streams
if $LIST; then
    response=$(curl -s "${GATEWAY_URL}/api/streams?limit=20" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo -e "${RED}æ— æ³•è¿æ¥ Gateway${NC}" >&2
        exit 1
    fi

    if $JSON; then
        echo "$response" | jq .
    else
        echo -e "${CYAN}æœ€è¿‘çš„è¯·æ±‚æµ:${NC}"
        echo ""
        echo "$response" | jq -r '.streams[] | "\(.request_id)\t\(.status.completed // false)\t\(.status.last_type // "?")\t\(.size) bytes"' | \
        while IFS=$'\t' read -r id completed last_type size; do
            if [[ "$completed" == "true" ]]; then
                status="${GREEN}âœ“${NC}"
            else
                status="${YELLOW}â³${NC}"
            fi
            printf "  %b %s  [%s]  %s\n" "$status" "$id" "$last_type" "$size"
        done
    fi
    exit 0
fi

# Get latest request ID
if $LATEST; then
    response=$(curl -s "${GATEWAY_URL}/api/streams?limit=1" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo -e "${RED}æ— æ³•è¿æ¥ Gateway${NC}" >&2
        exit 1
    fi

    REQUEST_ID=$(echo "$response" | jq -r '.streams[0].request_id // empty')
    if [[ -z "$REQUEST_ID" ]]; then
        echo -e "${YELLOW}æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æµ${NC}" >&2
        exit 1
    fi
    echo -e "${DIM}è·Ÿè¸ªè¯·æ±‚: ${REQUEST_ID}${NC}" >&2
fi

# Validate request ID
if [[ -z "$REQUEST_ID" ]]; then
    echo -e "${RED}é”™è¯¯: éœ€è¦æä¾› request_id${NC}" >&2
    show_help
    exit 1
fi

# Format entry for display
format_entry() {
    local entry="$1"
    local type=$(echo "$entry" | jq -r '.type')
    local time=$(echo "$entry" | jq -r '.time')
    local content=$(echo "$entry" | jq -r '.content')

    case "$type" in
        start)
            echo -e "${DIM}[$time]${NC} ${CYAN}â–¶ $content${NC}"
            ;;
        status)
            echo -e "${DIM}[$time]${NC} ${BLUE}â—† $content${NC}"
            ;;
        thinking)
            echo -e "${DIM}[$time]${NC} ${PURPLE}ğŸ§  æ€è€ƒé“¾:${NC}"
            echo "$content" | sed 's/^/    /'
            ;;
        chunk)
            echo -e "${DIM}[$time]${NC} ${DIM}$content${NC}"
            ;;
        output)
            echo -e "${DIM}[$time]${NC} ${GREEN}ğŸ“¤ è¾“å‡º:${NC}"
            echo "$content"
            ;;
        error)
            echo -e "${DIM}[$time]${NC} ${RED}âœ– $content${NC}"
            ;;
        complete)
            local success=$(echo "$entry" | jq -r '.meta.success // false')
            local elapsed=$(echo "$entry" | jq -r '.meta.elapsed_s // 0')
            if [[ "$success" == "true" ]]; then
                echo -e "${DIM}[$time]${NC} ${GREEN}âœ“ å®Œæˆ${NC} ${DIM}(${elapsed}s)${NC}"
            else
                local error=$(echo "$entry" | jq -r '.meta.error // "Unknown error"')
                echo -e "${DIM}[$time]${NC} ${RED}âœ– å¤±è´¥: $error${NC} ${DIM}(${elapsed}s)${NC}"
            fi
            ;;
        *)
            echo -e "${DIM}[$time]${NC} $type: $content"
            ;;
    esac
}

# One-shot mode: show last N lines
if ! $FOLLOW; then
    response=$(curl -s "${GATEWAY_URL}/api/stream/${REQUEST_ID}/tail?lines=${LINES}" 2>/dev/null)
    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo -e "${RED}æ— æ³•è·å–æµ: ${REQUEST_ID}${NC}" >&2
        exit 1
    fi

    error=$(echo "$response" | jq -r '.detail // empty')
    if [[ -n "$error" ]]; then
        echo -e "${RED}é”™è¯¯: $error${NC}" >&2
        exit 1
    fi

    if $JSON; then
        echo "$response" | jq .
    else
        total=$(echo "$response" | jq -r '.total_entries')
        echo -e "${CYAN}è¯·æ±‚: ${REQUEST_ID}${NC} ${DIM}(å…± $total æ¡è®°å½•)${NC}"
        echo ""
        echo "$response" | jq -c '.entries[]' | while read -r entry; do
            format_entry "$entry"
        done
    fi
    exit 0
fi

# Follow mode: continuously poll for new entries
echo -e "${CYAN}è·Ÿè¸ªè¯·æ±‚: ${REQUEST_ID}${NC}"
echo -e "${DIM}æŒ‰ Ctrl+C é€€å‡º${NC}"
echo ""

next_line=0
completed=false
wait_count=0
max_wait=20  # æœ€å¤šç­‰å¾… 10 ç§’ (0.5s * 20)

while ! $completed; do
    response=$(curl -s "${GATEWAY_URL}/api/stream/${REQUEST_ID}?from_line=${next_line}" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        sleep 0.5
        continue
    fi

    error=$(echo "$response" | jq -r '.detail // empty')
    if [[ -n "$error" ]]; then
        # Stream not found - wait for it to be created
        if [[ "$error" == "Stream not found" ]] && [[ $wait_count -lt $max_wait ]]; then
            ((wait_count++))
            sleep 0.5
            continue
        fi
        echo -e "${RED}é”™è¯¯: $error${NC}" >&2
        exit 1
    fi

    wait_count=0  # Reset wait count on success

    # Process new entries
    entry_count=$(echo "$response" | jq -r '.entry_count')
    if [[ "$entry_count" -gt 0 ]]; then
        if $JSON; then
            echo "$response" | jq -c '.entries[]'
        else
            echo "$response" | jq -c '.entries[]' | while read -r entry; do
                format_entry "$entry"
            done
        fi
        next_line=$(echo "$response" | jq -r '.next_line')
    fi

    # Check if completed
    completed=$(echo "$response" | jq -r '.status.completed // false')
    if $completed; then
        echo ""
        echo -e "${DIM}--- æµç»“æŸ ---${NC}"
        break
    fi

    # Poll interval
    sleep 0.5
done
