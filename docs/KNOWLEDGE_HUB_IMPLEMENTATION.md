# Knowledge Hub å®ç°è®¡åˆ’

**ç›®æ ‡**: å°† NotebookLM + Obsidian + MinerU é›†æˆä¸º Hivemind çš„ç»Ÿä¸€çŸ¥è¯†åº“å±‚

**æ‰§è¡Œè€…**: Codex
**é¢„è®¡æ—¶é—´**: 4-6 å°æ—¶

---

## ğŸ“Š ç³»ç»Ÿæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Knowledge Hub (ç»Ÿä¸€çŸ¥è¯†åº“)                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚   â”‚ NotebookLM  â”‚   â”‚  Obsidian   â”‚   â”‚   MinerU    â”‚        â”‚
â”‚   â”‚ (äº‘ç«¯ç ”ç©¶)   â”‚   â”‚ (æœ¬åœ°ç¬”è®°)   â”‚   â”‚ (PDFè½¬æ¢)   â”‚        â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚          â”‚                 â”‚                 â”‚                â”‚
â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                â”‚
â”‚                            â–¼                                  â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                  â”‚ Knowledge Router â”‚                         â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                           â”‚                                   â”‚
â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚          â–¼                â–¼                â–¼                  â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚   â”‚ æœ¬åœ°ç´¢å¼•DB â”‚  â”‚ æŸ¥è¯¢ç¼“å­˜   â”‚  â”‚ Gateway API    â”‚         â”‚
â”‚   â”‚ (SQLite)   â”‚  â”‚ (TTL 24h)  â”‚  â”‚ (/knowledge/*) â”‚         â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ æ–‡ä»¶ç»“æ„

```
~/.local/share/codex-dual/
â”œâ”€â”€ lib/
â”‚   â””â”€â”€ knowledge/                    # ğŸ†• æ–°å»ºç›®å½•
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ router.py                 # çŸ¥è¯†è·¯ç”±å™¨ï¼ˆæ ¸å¿ƒï¼‰
â”‚       â”œâ”€â”€ notebooklm_client.py      # NotebookLM CLI å°è£…
â”‚       â”œâ”€â”€ obsidian_search.py        # Obsidian æœ¬åœ°æœç´¢
â”‚       â”œâ”€â”€ index_manager.py          # SQLite ç´¢å¼•ç®¡ç†
â”‚       â””â”€â”€ cache.py                  # æŸ¥è¯¢ç¼“å­˜
â”œâ”€â”€ data/
â”‚   â””â”€â”€ knowledge_index.db            # ğŸ†• SQLite ç´¢å¼•æ•°æ®åº“
â””â”€â”€ config/
    â””â”€â”€ knowledge.yaml                # ğŸ†• é…ç½®æ–‡ä»¶
```

---

## ğŸ”§ Phase 1: åŸºç¡€è®¾æ–½ (1.5h)

### Task 1.1: åˆ›å»ºç›®å½•ç»“æ„

```bash
mkdir -p ~/.local/share/codex-dual/lib/knowledge
mkdir -p ~/.local/share/codex-dual/data
mkdir -p ~/.local/share/codex-dual/config
```

### Task 1.2: åˆ›å»º SQLite Schema

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/knowledge/schema.sql`

```sql
-- notebooks è¡¨ (NotebookLM notebooks)
CREATE TABLE IF NOT EXISTS notebooks (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    description TEXT,
    topics TEXT,                   -- JSON array: ["å†å²", "ç½—é©¬"]
    source_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    last_queried TIMESTAMP,
    query_count INTEGER DEFAULT 0
);

-- sources è¡¨ (notebook å†…çš„æ–‡æ¡£æ¥æº)
CREATE TABLE IF NOT EXISTS sources (
    id TEXT PRIMARY KEY,
    notebook_id TEXT,
    title TEXT,
    type TEXT,                     -- pdf, url, markdown
    page_count INTEGER,
    FOREIGN KEY (notebook_id) REFERENCES notebooks(id)
);

-- obsidian_notes è¡¨ (æœ¬åœ° Obsidian ç¬”è®°ç´¢å¼•)
CREATE TABLE IF NOT EXISTS obsidian_notes (
    path TEXT PRIMARY KEY,
    title TEXT,
    tags TEXT,                     -- JSON array
    links TEXT,                    -- JSON array (wikilinks)
    word_count INTEGER,
    modified_at TIMESTAMP,
    indexed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- query_cache è¡¨
CREATE TABLE IF NOT EXISTS query_cache (
    query_hash TEXT PRIMARY KEY,
    source TEXT,                   -- "notebooklm" | "obsidian"
    question TEXT,
    answer TEXT,
    references TEXT,               -- JSON
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ttl INTEGER DEFAULT 86400
);

-- ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_notebooks_topics ON notebooks(topics);
CREATE INDEX IF NOT EXISTS idx_obsidian_tags ON obsidian_notes(tags);
CREATE INDEX IF NOT EXISTS idx_cache_created ON query_cache(created_at);
```

### Task 1.3: åˆ›å»ºé…ç½®æ–‡ä»¶

**æ–‡ä»¶**: `~/.local/share/codex-dual/config/knowledge.yaml`

```yaml
knowledge:
  # æ•°æ®åº“
  db_path: ~/.local/share/codex-dual/data/knowledge_index.db

  # Obsidian é…ç½®
  obsidian:
    vault_path: ~/Documents/Obsidian/Main
    excluded_folders:
      - .obsidian
      - .trash
      - templates

  # NotebookLM é…ç½®
  notebooklm:
    timeout: 30
    max_retries: 2

  # ç¼“å­˜é…ç½®
  cache:
    enabled: true
    ttl: 86400              # 24å°æ—¶
    max_entries: 1000

  # è·¯ç”±é…ç½®
  routing:
    default_source: auto    # auto | notebooklm | obsidian
    local_first: true       # ä¼˜å…ˆæŸ¥æœ¬åœ°
    confidence_threshold: 0.7
```

---

## ğŸ”§ Phase 2: æ ¸å¿ƒæ¨¡å— (2h)

### Task 2.1: NotebookLM Client

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/knowledge/notebooklm_client.py`

```python
"""
NotebookLM CLI å°è£…

ä¾èµ–: notebooklm CLI (npm i -g notebooklm)
"""

import subprocess
import json
from typing import Optional, List, Dict, Any
from pathlib import Path


class NotebookLMClient:
    """NotebookLM CLI å®¢æˆ·ç«¯"""

    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        self._check_cli()

    def _check_cli(self):
        """æ£€æŸ¥ notebooklm CLI æ˜¯å¦å¯ç”¨"""
        try:
            result = subprocess.run(
                ['notebooklm', '--version'],
                capture_output=True,
                timeout=5
            )
            if result.returncode != 0:
                raise RuntimeError("notebooklm CLI not found")
        except FileNotFoundError:
            raise RuntimeError("notebooklm CLI not installed. Run: npm i -g notebooklm")

    def list_notebooks(self) -> List[Dict[str, Any]]:
        """åˆ—å‡ºæ‰€æœ‰ notebooks"""
        result = subprocess.run(
            ['notebooklm', 'list', '--json'],
            capture_output=True,
            text=True,
            timeout=self.timeout
        )
        if result.returncode == 0:
            return json.loads(result.stdout)
        return []

    def query(self, notebook_id: str, question: str) -> Dict[str, Any]:
        """æŸ¥è¯¢æŒ‡å®š notebook"""
        result = subprocess.run(
            ['notebooklm', 'ask', notebook_id, question, '--json'],
            capture_output=True,
            text=True,
            timeout=self.timeout
        )
        if result.returncode == 0:
            return json.loads(result.stdout)
        return {
            'answer': None,
            'error': result.stderr,
            'references': []
        }

    def search_notebooks(self, query: str) -> List[Dict[str, Any]]:
        """æœç´¢ç›¸å…³ notebooks"""
        result = subprocess.run(
            ['notebooklm', 'search', query, '--json'],
            capture_output=True,
            text=True,
            timeout=self.timeout
        )
        if result.returncode == 0:
            return json.loads(result.stdout)
        return []

    def get_notebook_info(self, notebook_id: str) -> Optional[Dict[str, Any]]:
        """è·å– notebook è¯¦æƒ…"""
        result = subprocess.run(
            ['notebooklm', 'info', notebook_id, '--json'],
            capture_output=True,
            text=True,
            timeout=self.timeout
        )
        if result.returncode == 0:
            return json.loads(result.stdout)
        return None
```

### Task 2.2: Obsidian Search

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/knowledge/obsidian_search.py`

```python
"""
Obsidian æœ¬åœ°ç¬”è®°æœç´¢

æ”¯æŒ:
- å…¨æ–‡æœç´¢
- æ ‡ç­¾æœç´¢
- Wikilink æœç´¢
"""

import os
import re
import yaml
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime


class ObsidianSearch:
    """Obsidian Vault æœç´¢å™¨"""

    def __init__(self, vault_path: str, excluded_folders: List[str] = None):
        self.vault_path = Path(vault_path).expanduser()
        self.excluded_folders = excluded_folders or ['.obsidian', '.trash']

        if not self.vault_path.exists():
            raise ValueError(f"Vault not found: {self.vault_path}")

    def search(self, query: str, limit: int = 10) -> List[Dict[str, Any]]:
        """å…¨æ–‡æœç´¢"""
        results = []
        query_lower = query.lower()
        query_words = query_lower.split()

        for md_file in self._iter_markdown_files():
            try:
                content = md_file.read_text(encoding='utf-8')
                content_lower = content.lower()

                # è®¡ç®—ç›¸å…³æ€§åˆ†æ•°
                score = self._calculate_relevance(content_lower, query_words)

                if score > 0:
                    # æå–å…ƒæ•°æ®
                    metadata = self._extract_metadata(content)

                    results.append({
                        'path': str(md_file.relative_to(self.vault_path)),
                        'title': metadata.get('title', md_file.stem),
                        'tags': metadata.get('tags', []),
                        'score': score,
                        'snippet': self._extract_snippet(content, query_words),
                        'modified_at': datetime.fromtimestamp(md_file.stat().st_mtime).isoformat()
                    })
            except Exception as e:
                continue

        # æŒ‰åˆ†æ•°æ’åº
        results.sort(key=lambda x: x['score'], reverse=True)
        return results[:limit]

    def search_by_tag(self, tag: str, limit: int = 20) -> List[Dict[str, Any]]:
        """æŒ‰æ ‡ç­¾æœç´¢"""
        results = []
        tag_pattern = f"#{tag}"

        for md_file in self._iter_markdown_files():
            try:
                content = md_file.read_text(encoding='utf-8')
                if tag_pattern in content:
                    metadata = self._extract_metadata(content)
                    results.append({
                        'path': str(md_file.relative_to(self.vault_path)),
                        'title': metadata.get('title', md_file.stem),
                        'tags': metadata.get('tags', [])
                    })
            except:
                continue

        return results[:limit]

    def get_note(self, path: str) -> Optional[Dict[str, Any]]:
        """è·å–ç¬”è®°å†…å®¹"""
        full_path = self.vault_path / path
        if not full_path.exists():
            return None

        content = full_path.read_text(encoding='utf-8')
        metadata = self._extract_metadata(content)

        return {
            'path': path,
            'title': metadata.get('title', full_path.stem),
            'tags': metadata.get('tags', []),
            'content': content,
            'word_count': len(content.split())
        }

    def _iter_markdown_files(self):
        """éå†æ‰€æœ‰ Markdown æ–‡ä»¶"""
        for root, dirs, files in os.walk(self.vault_path):
            # æ’é™¤æŒ‡å®šæ–‡ä»¶å¤¹
            dirs[:] = [d for d in dirs if d not in self.excluded_folders]

            for file in files:
                if file.endswith('.md'):
                    yield Path(root) / file

    def _extract_metadata(self, content: str) -> Dict[str, Any]:
        """æå– YAML frontmatter"""
        if content.startswith('---'):
            try:
                end = content.index('---', 3)
                frontmatter = content[3:end]
                return yaml.safe_load(frontmatter) or {}
            except:
                pass
        return {}

    def _calculate_relevance(self, content: str, query_words: List[str]) -> float:
        """è®¡ç®—ç›¸å…³æ€§åˆ†æ•°"""
        score = 0
        for word in query_words:
            count = content.count(word)
            if count > 0:
                score += min(count, 10)  # æ¯ä¸ªè¯æœ€å¤šè´¡çŒ® 10 åˆ†
        return score

    def _extract_snippet(self, content: str, query_words: List[str], context: int = 100) -> str:
        """æå–åŒ…å«æŸ¥è¯¢è¯çš„ç‰‡æ®µ"""
        content_lower = content.lower()
        for word in query_words:
            idx = content_lower.find(word)
            if idx >= 0:
                start = max(0, idx - context)
                end = min(len(content), idx + len(word) + context)
                snippet = content[start:end]
                if start > 0:
                    snippet = '...' + snippet
                if end < len(content):
                    snippet = snippet + '...'
                return snippet
        return content[:200] + '...'
```

### Task 2.3: Index Manager

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/knowledge/index_manager.py`

```python
"""
çŸ¥è¯†åº“ç´¢å¼•ç®¡ç†å™¨

ç®¡ç† SQLite ç´¢å¼•æ•°æ®åº“
"""

import sqlite3
import json
from pathlib import Path
from typing import List, Dict, Any, Optional
from datetime import datetime


class IndexManager:
    """çŸ¥è¯†åº“ç´¢å¼•ç®¡ç†å™¨"""

    def __init__(self, db_path: str):
        self.db_path = Path(db_path).expanduser()
        self.db_path.parent.mkdir(parents=True, exist_ok=True)
        self._init_db()

    def _init_db(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        schema_path = Path(__file__).parent / 'schema.sql'

        with sqlite3.connect(self.db_path) as conn:
            if schema_path.exists():
                conn.executescript(schema_path.read_text())
            else:
                # å†…è” schema
                conn.executescript('''
                    CREATE TABLE IF NOT EXISTS notebooks (
                        id TEXT PRIMARY KEY,
                        title TEXT NOT NULL,
                        description TEXT,
                        topics TEXT,
                        source_count INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        last_queried TIMESTAMP,
                        query_count INTEGER DEFAULT 0
                    );

                    CREATE TABLE IF NOT EXISTS query_cache (
                        query_hash TEXT PRIMARY KEY,
                        source TEXT,
                        question TEXT,
                        answer TEXT,
                        references TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        ttl INTEGER DEFAULT 86400
                    );
                ''')

    # === Notebooks ===

    def upsert_notebook(self, notebook: Dict[str, Any]):
        """æ’å…¥æˆ–æ›´æ–° notebook"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                INSERT OR REPLACE INTO notebooks
                (id, title, description, topics, source_count, created_at)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                notebook['id'],
                notebook.get('title', ''),
                notebook.get('description', ''),
                json.dumps(notebook.get('topics', [])),
                notebook.get('source_count', 0),
                notebook.get('created_at', datetime.now().isoformat())
            ))

    def get_notebook(self, notebook_id: str) -> Optional[Dict[str, Any]]:
        """è·å– notebook"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            row = conn.execute(
                'SELECT * FROM notebooks WHERE id = ?',
                (notebook_id,)
            ).fetchone()

            if row:
                return dict(row)
        return None

    def search_notebooks(self, topic: str) -> List[Dict[str, Any]]:
        """æŒ‰ä¸»é¢˜æœç´¢ notebooks"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            rows = conn.execute(
                'SELECT * FROM notebooks WHERE topics LIKE ?',
                (f'%{topic}%',)
            ).fetchall()
            return [dict(row) for row in rows]

    def record_query(self, notebook_id: str):
        """è®°å½•æŸ¥è¯¢"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                UPDATE notebooks
                SET last_queried = ?, query_count = query_count + 1
                WHERE id = ?
            ''', (datetime.now().isoformat(), notebook_id))

    # === Cache ===

    def get_cached(self, query_hash: str) -> Optional[Dict[str, Any]]:
        """è·å–ç¼“å­˜"""
        with sqlite3.connect(self.db_path) as conn:
            conn.row_factory = sqlite3.Row
            row = conn.execute('''
                SELECT * FROM query_cache
                WHERE query_hash = ?
                AND datetime(created_at, '+' || ttl || ' seconds') > datetime('now')
            ''', (query_hash,)).fetchone()

            if row:
                result = dict(row)
                result['references'] = json.loads(result.get('references', '[]'))
                return result
        return None

    def set_cached(self, query_hash: str, source: str, question: str,
                   answer: str, references: List[Dict], ttl: int = 86400):
        """è®¾ç½®ç¼“å­˜"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                INSERT OR REPLACE INTO query_cache
                (query_hash, source, question, answer, references, ttl)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (
                query_hash, source, question, answer,
                json.dumps(references), ttl
            ))

    def clear_expired_cache(self):
        """æ¸…ç†è¿‡æœŸç¼“å­˜"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute('''
                DELETE FROM query_cache
                WHERE datetime(created_at, '+' || ttl || ' seconds') < datetime('now')
            ''')

    # === Stats ===

    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        with sqlite3.connect(self.db_path) as conn:
            notebook_count = conn.execute(
                'SELECT COUNT(*) FROM notebooks'
            ).fetchone()[0]

            cache_count = conn.execute(
                'SELECT COUNT(*) FROM query_cache'
            ).fetchone()[0]

            total_queries = conn.execute(
                'SELECT SUM(query_count) FROM notebooks'
            ).fetchone()[0] or 0

            return {
                'notebook_count': notebook_count,
                'cache_count': cache_count,
                'total_queries': total_queries
            }
```

### Task 2.4: Knowledge Router (æ ¸å¿ƒ)

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/knowledge/router.py`

```python
"""
Knowledge Router - ç»Ÿä¸€çŸ¥è¯†è·¯ç”±å™¨

æ ¸å¿ƒç»„ä»¶ï¼Œè´Ÿè´£ï¼š
1. æ™ºèƒ½è·¯ç”±æŸ¥è¯¢åˆ°æ­£ç¡®çš„çŸ¥è¯†æº
2. ç¼“å­˜ç®¡ç†
3. ç»“æœåˆå¹¶
"""

import hashlib
import yaml
from pathlib import Path
from typing import Dict, Any, Optional, List

from .notebooklm_client import NotebookLMClient
from .obsidian_search import ObsidianSearch
from .index_manager import IndexManager


class KnowledgeRouter:
    """ç»Ÿä¸€çŸ¥è¯†è·¯ç”±å™¨"""

    def __init__(self, config_path: str = None):
        self.config = self._load_config(config_path)

        # åˆå§‹åŒ–ç»„ä»¶
        self.index = IndexManager(self.config['knowledge']['db_path'])

        # NotebookLM (å¯é€‰)
        self.notebooklm = None
        try:
            self.notebooklm = NotebookLMClient(
                timeout=self.config['knowledge']['notebooklm']['timeout']
            )
        except Exception as e:
            print(f"[KnowledgeRouter] NotebookLM not available: {e}")

        # Obsidian (å¯é€‰)
        self.obsidian = None
        obsidian_config = self.config['knowledge'].get('obsidian', {})
        vault_path = obsidian_config.get('vault_path')
        if vault_path and Path(vault_path).expanduser().exists():
            self.obsidian = ObsidianSearch(
                vault_path,
                obsidian_config.get('excluded_folders', [])
            )

        print(f"[KnowledgeRouter] Initialized: "
              f"NotebookLM={'âœ“' if self.notebooklm else 'âœ—'}, "
              f"Obsidian={'âœ“' if self.obsidian else 'âœ—'}")

    def _load_config(self, config_path: str = None) -> Dict[str, Any]:
        """åŠ è½½é…ç½®"""
        if config_path is None:
            config_path = Path.home() / '.local/share/codex-dual/config/knowledge.yaml'

        config_path = Path(config_path).expanduser()

        if config_path.exists():
            with open(config_path) as f:
                return yaml.safe_load(f)

        # é»˜è®¤é…ç½®
        return {
            'knowledge': {
                'db_path': '~/.local/share/codex-dual/data/knowledge_index.db',
                'obsidian': {
                    'vault_path': '~/Documents/Obsidian/Main',
                    'excluded_folders': ['.obsidian', '.trash']
                },
                'notebooklm': {
                    'timeout': 30,
                    'max_retries': 2
                },
                'cache': {
                    'enabled': True,
                    'ttl': 86400
                },
                'routing': {
                    'default_source': 'auto',
                    'local_first': True,
                    'confidence_threshold': 0.7
                }
            }
        }

    def query(
        self,
        question: str,
        source: str = 'auto',
        notebook_id: str = None,
        use_cache: bool = True
    ) -> Dict[str, Any]:
        """
        ç»Ÿä¸€æŸ¥è¯¢æ¥å£

        Args:
            question: é—®é¢˜
            source: çŸ¥è¯†æº ("auto" | "notebooklm" | "obsidian")
            notebook_id: æŒ‡å®š NotebookLM notebook ID
            use_cache: æ˜¯å¦ä½¿ç”¨ç¼“å­˜

        Returns:
            {
                'answer': str,
                'source': str,
                'references': List[Dict],
                'cached': bool,
                'confidence': float
            }
        """
        # 1. æ£€æŸ¥ç¼“å­˜
        if use_cache and self.config['knowledge']['cache']['enabled']:
            query_hash = self._hash_query(question, source, notebook_id)
            cached = self.index.get_cached(query_hash)
            if cached:
                return {
                    'answer': cached['answer'],
                    'source': cached['source'],
                    'references': cached['references'],
                    'cached': True,
                    'confidence': 1.0
                }

        # 2. è·¯ç”±æŸ¥è¯¢
        if source == 'auto':
            result = self._auto_route(question, notebook_id)
        elif source == 'notebooklm':
            result = self._query_notebooklm(question, notebook_id)
        elif source == 'obsidian':
            result = self._query_obsidian(question)
        else:
            raise ValueError(f"Unknown source: {source}")

        # 3. ç¼“å­˜ç»“æœ
        if use_cache and result.get('answer'):
            query_hash = self._hash_query(question, source, notebook_id)
            self.index.set_cached(
                query_hash=query_hash,
                source=result['source'],
                question=question,
                answer=result['answer'],
                references=result.get('references', []),
                ttl=self.config['knowledge']['cache']['ttl']
            )

        result['cached'] = False
        return result

    def _auto_route(self, question: str, notebook_id: str = None) -> Dict[str, Any]:
        """æ™ºèƒ½è·¯ç”±"""
        routing_config = self.config['knowledge']['routing']

        # å¦‚æœæŒ‡å®šäº† notebook_idï¼Œç›´æ¥æŸ¥ NotebookLM
        if notebook_id and self.notebooklm:
            return self._query_notebooklm(question, notebook_id)

        # æœ¬åœ°ä¼˜å…ˆç­–ç•¥
        if routing_config.get('local_first', True) and self.obsidian:
            local_result = self._query_obsidian(question)
            if local_result.get('confidence', 0) >= routing_config.get('confidence_threshold', 0.7):
                return local_result

        # æŸ¥è¯¢ NotebookLM
        if self.notebooklm:
            return self._query_notebooklm(question, notebook_id)

        # å›é€€åˆ°æœ¬åœ°
        if self.obsidian:
            return self._query_obsidian(question)

        return {
            'answer': None,
            'source': 'none',
            'references': [],
            'confidence': 0,
            'error': 'No knowledge source available'
        }

    def _query_notebooklm(self, question: str, notebook_id: str = None) -> Dict[str, Any]:
        """æŸ¥è¯¢ NotebookLM"""
        if not self.notebooklm:
            return {'answer': None, 'source': 'notebooklm', 'error': 'NotebookLM not available'}

        try:
            # å¦‚æœæ²¡æœ‰æŒ‡å®š notebookï¼Œæœç´¢ç›¸å…³çš„
            if not notebook_id:
                notebooks = self.notebooklm.search_notebooks(question)
                if notebooks:
                    notebook_id = notebooks[0]['id']
                else:
                    return {'answer': None, 'source': 'notebooklm', 'error': 'No relevant notebook found'}

            # æŸ¥è¯¢
            result = self.notebooklm.query(notebook_id, question)

            # è®°å½•æŸ¥è¯¢
            self.index.record_query(notebook_id)

            return {
                'answer': result.get('answer'),
                'source': 'notebooklm',
                'notebook_id': notebook_id,
                'references': result.get('references', []),
                'confidence': 0.9 if result.get('answer') else 0
            }
        except Exception as e:
            return {'answer': None, 'source': 'notebooklm', 'error': str(e)}

    def _query_obsidian(self, question: str) -> Dict[str, Any]:
        """æŸ¥è¯¢ Obsidian"""
        if not self.obsidian:
            return {'answer': None, 'source': 'obsidian', 'error': 'Obsidian not available'}

        try:
            results = self.obsidian.search(question, limit=5)

            if not results:
                return {
                    'answer': None,
                    'source': 'obsidian',
                    'references': [],
                    'confidence': 0
                }

            # ç»„åˆç­”æ¡ˆ
            top_result = results[0]
            note = self.obsidian.get_note(top_result['path'])

            # è®¡ç®—ç½®ä¿¡åº¦
            confidence = min(top_result['score'] / 50, 1.0)

            return {
                'answer': note['content'][:2000] if note else top_result['snippet'],
                'source': 'obsidian',
                'references': [
                    {
                        'title': r['title'],
                        'path': r['path'],
                        'score': r['score']
                    }
                    for r in results
                ],
                'confidence': confidence
            }
        except Exception as e:
            return {'answer': None, 'source': 'obsidian', 'error': str(e)}

    def _hash_query(self, question: str, source: str, notebook_id: str = None) -> str:
        """ç”ŸæˆæŸ¥è¯¢å“ˆå¸Œ"""
        key = f"{question}:{source}:{notebook_id or ''}"
        return hashlib.md5(key.encode()).hexdigest()

    # === åŒæ­¥æ–¹æ³• ===

    def sync_notebooklm(self) -> int:
        """åŒæ­¥ NotebookLM notebooks åˆ°æœ¬åœ°ç´¢å¼•"""
        if not self.notebooklm:
            return 0

        notebooks = self.notebooklm.list_notebooks()
        for nb in notebooks:
            self.index.upsert_notebook(nb)

        return len(notebooks)

    def get_stats(self) -> Dict[str, Any]:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        return {
            'index': self.index.get_stats(),
            'notebooklm_available': self.notebooklm is not None,
            'obsidian_available': self.obsidian is not None
        }
```

### Task 2.5: æ¨¡å—åˆå§‹åŒ–

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/knowledge/__init__.py`

```python
"""
Knowledge Hub - ç»Ÿä¸€çŸ¥è¯†åº“æ¨¡å—

æä¾›å¯¹ NotebookLM + Obsidian çš„ç»Ÿä¸€è®¿é—®æ¥å£
"""

from .router import KnowledgeRouter
from .notebooklm_client import NotebookLMClient
from .obsidian_search import ObsidianSearch
from .index_manager import IndexManager

__all__ = [
    'KnowledgeRouter',
    'NotebookLMClient',
    'ObsidianSearch',
    'IndexManager'
]

__version__ = '0.1.0'
```

---

## ğŸ”§ Phase 3: Gateway API é›†æˆ (1.5h)

### Task 3.1: Knowledge API ç«¯ç‚¹

**æ–‡ä»¶**: `~/.local/share/codex-dual/lib/gateway/knowledge_api.py`

```python
"""
Knowledge Hub Gateway API

ç«¯ç‚¹:
- POST /knowledge/query    æŸ¥è¯¢çŸ¥è¯†åº“
- POST /knowledge/sync     åŒæ­¥ç´¢å¼•
- GET  /knowledge/stats    ç»Ÿè®¡ä¿¡æ¯
- GET  /knowledge/notebooks åˆ—å‡º notebooks
"""

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import Optional, List, Dict, Any

# å¯¼å…¥çŸ¥è¯†æ¨¡å—
import sys
from pathlib import Path
sys.path.insert(0, str(Path(__file__).parent.parent))

from knowledge import KnowledgeRouter


router = APIRouter(prefix='/knowledge', tags=['knowledge'])

# å…¨å±€ router å®ä¾‹
_knowledge_router: Optional[KnowledgeRouter] = None


def get_knowledge_router() -> KnowledgeRouter:
    """è·å– KnowledgeRouter å•ä¾‹"""
    global _knowledge_router
    if _knowledge_router is None:
        _knowledge_router = KnowledgeRouter()
    return _knowledge_router


# === Request/Response Models ===

class QueryRequest(BaseModel):
    question: str
    source: str = 'auto'  # auto | notebooklm | obsidian
    notebook_id: Optional[str] = None
    use_cache: bool = True


class QueryResponse(BaseModel):
    answer: Optional[str]
    source: str
    references: List[Dict[str, Any]] = []
    cached: bool = False
    confidence: float = 0
    error: Optional[str] = None


class SyncResponse(BaseModel):
    notebooks_synced: int
    success: bool
    message: str


class StatsResponse(BaseModel):
    index: Dict[str, Any]
    notebooklm_available: bool
    obsidian_available: bool


# === Endpoints ===

@router.post('/query', response_model=QueryResponse)
async def query_knowledge(request: QueryRequest):
    """
    æŸ¥è¯¢çŸ¥è¯†åº“

    - **question**: é—®é¢˜
    - **source**: çŸ¥è¯†æº (auto/notebooklm/obsidian)
    - **notebook_id**: æŒ‡å®š NotebookLM notebook
    - **use_cache**: æ˜¯å¦ä½¿ç”¨ç¼“å­˜
    """
    try:
        kr = get_knowledge_router()
        result = kr.query(
            question=request.question,
            source=request.source,
            notebook_id=request.notebook_id,
            use_cache=request.use_cache
        )
        return QueryResponse(**result)
    except Exception as e:
        return QueryResponse(
            answer=None,
            source=request.source,
            error=str(e)
        )


@router.post('/sync', response_model=SyncResponse)
async def sync_knowledge():
    """åŒæ­¥ NotebookLM notebooks åˆ°æœ¬åœ°ç´¢å¼•"""
    try:
        kr = get_knowledge_router()
        count = kr.sync_notebooklm()
        return SyncResponse(
            notebooks_synced=count,
            success=True,
            message=f'Synced {count} notebooks'
        )
    except Exception as e:
        return SyncResponse(
            notebooks_synced=0,
            success=False,
            message=str(e)
        )


@router.get('/stats', response_model=StatsResponse)
async def get_stats():
    """è·å–çŸ¥è¯†åº“ç»Ÿè®¡ä¿¡æ¯"""
    kr = get_knowledge_router()
    return StatsResponse(**kr.get_stats())


@router.get('/notebooks')
async def list_notebooks(topic: Optional[str] = None):
    """åˆ—å‡ºæ‰€æœ‰å·²ç´¢å¼•çš„ notebooks"""
    kr = get_knowledge_router()
    if topic:
        return kr.index.search_notebooks(topic)

    # è¿”å›æ‰€æœ‰
    with kr.index.db_path.open() as f:
        # ç®€å•å®ç°
        pass
    return []
```

### Task 3.2: é›†æˆåˆ° Gateway Server

**ä¿®æ”¹æ–‡ä»¶**: `~/.local/share/codex-dual/lib/gateway/gateway_server.py`

åœ¨ `create_app()` å‡½æ•°ä¸­æ·»åŠ :

```python
# åœ¨å…¶ä»– router å¯¼å…¥åæ·»åŠ 
from .knowledge_api import router as knowledge_router

# åœ¨ app åˆ›å»ºåæ·»åŠ 
app.include_router(knowledge_router)
```

---

## ğŸ”§ Phase 4: CLI é›†æˆ (1h)

### Task 4.1: ccb-knowledge å‘½ä»¤

**æ–‡ä»¶**: `~/.local/share/codex-dual/bin/ccb-knowledge`

```bash
#!/bin/bash
# ccb-knowledge - çŸ¥è¯†åº“ CLI
# ç”¨æ³•: ccb-knowledge <command> [options]

set -e

GATEWAY_URL="${GATEWAY_URL:-http://localhost:8765}"
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

show_help() {
    cat << 'EOF'
ccb-knowledge - çŸ¥è¯†åº“ CLI

ç”¨æ³•:
  ccb-knowledge query "é—®é¢˜"              æŸ¥è¯¢çŸ¥è¯†åº“
  ccb-knowledge query "é—®é¢˜" --source X   æŒ‡å®šçŸ¥è¯†æº (notebooklm/obsidian)
  ccb-knowledge sync                      åŒæ­¥ NotebookLM ç´¢å¼•
  ccb-knowledge stats                     æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯
  ccb-knowledge list                      åˆ—å‡ºæ‰€æœ‰ notebooks

ç¤ºä¾‹:
  ccb-knowledge query "ç½—é©¬å¸å›½è¡°è½çš„åŸå› "
  ccb-knowledge query "é€’å½’" --source obsidian
  ccb-knowledge sync
EOF
}

query() {
    local question="$1"
    local source="${2:-auto}"

    curl -s -X POST "$GATEWAY_URL/knowledge/query" \
        -H "Content-Type: application/json" \
        -d "{\"question\": \"$question\", \"source\": \"$source\"}" \
        | jq -r '.answer // .error // "No answer found"'
}

sync_index() {
    curl -s -X POST "$GATEWAY_URL/knowledge/sync" \
        | jq .
}

get_stats() {
    curl -s "$GATEWAY_URL/knowledge/stats" \
        | jq .
}

list_notebooks() {
    curl -s "$GATEWAY_URL/knowledge/notebooks" \
        | jq .
}

# è§£æå‘½ä»¤
case "${1:-help}" in
    query)
        shift
        question=""
        source="auto"

        while [[ $# -gt 0 ]]; do
            case "$1" in
                --source|-s)
                    source="$2"
                    shift 2
                    ;;
                *)
                    question="$1"
                    shift
                    ;;
            esac
        done

        if [[ -z "$question" ]]; then
            echo "Error: Question required"
            exit 1
        fi

        query "$question" "$source"
        ;;
    sync)
        sync_index
        ;;
    stats)
        get_stats
        ;;
    list)
        list_notebooks
        ;;
    help|--help|-h)
        show_help
        ;;
    *)
        echo "Unknown command: $1"
        show_help
        exit 1
        ;;
esac
```

### Task 4.2: è®¾ç½®å¯æ‰§è¡Œæƒé™

```bash
chmod +x ~/.local/share/codex-dual/bin/ccb-knowledge
```

---

## âœ… éªŒæ”¶æ ‡å‡†

å®Œæˆåæ‰§è¡Œä»¥ä¸‹æµ‹è¯•:

```bash
# 1. åŸºç¡€è®¾æ–½
ls -la ~/.local/share/codex-dual/lib/knowledge/
ls -la ~/.local/share/codex-dual/data/knowledge_index.db
cat ~/.local/share/codex-dual/config/knowledge.yaml

# 2. Python æ¨¡å—
python3 -c "from lib.knowledge import KnowledgeRouter; print('OK')"

# 3. Gateway API
curl -s http://localhost:8765/knowledge/stats | jq .

# 4. CLI
ccb-knowledge stats
ccb-knowledge query "æµ‹è¯•é—®é¢˜"

# 5. åŒæ­¥æµ‹è¯• (å¦‚æœæœ‰ NotebookLM)
ccb-knowledge sync
```

---

## ğŸ“Š é¢„æœŸç»“æœ

| ç»„ä»¶ | çŠ¶æ€ | è¯´æ˜ |
|------|------|------|
| `lib/knowledge/` æ¨¡å— | âœ… | 5 ä¸ª Python æ–‡ä»¶ |
| `knowledge_index.db` | âœ… | SQLite æ•°æ®åº“å·²åˆ›å»º |
| `knowledge.yaml` | âœ… | é…ç½®æ–‡ä»¶ |
| `/knowledge/*` API | âœ… | 4 ä¸ªç«¯ç‚¹ |
| `ccb-knowledge` CLI | âœ… | å¯æ‰§è¡Œ |
| Obsidian æœç´¢ | âœ… | å¦‚æœ vault å­˜åœ¨ |
| NotebookLM æŸ¥è¯¢ | âš ï¸ | å–å†³äº CLI å®‰è£… |

---

## ğŸ”— ç›¸å…³æ–‡ä»¶

- åŸå§‹è®¡åˆ’: `~/.claude/skills/knowledge-hub/CCB_INTEGRATION_PLAN.md`
- Skill å®šä¹‰: `~/.claude/skills/knowledge-hub/SKILL.md`
- Gateway ä»£ç : `~/.local/share/codex-dual/lib/gateway/`
- Memory ç³»ç»Ÿ: `~/.local/share/codex-dual/lib/memory/`
